Add to [version.syn]{.sref} (Header `<version>` synopsis):

```diff
- #define __cpp_lib_constexpr_memory                202202L // freestanding, also in <memory>
+ #define __cpp_lib_constexpr_memory                YYYYMML // freestanding, also in <memory>
```

Add to [memory.syn]{.sref} (Header `<memory>` synopsis):

```
@[`constexpr`]{.add}@ bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ compare_three_way_result_t<typename unique_ptr<T1, D1>::pointer,
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(Args&&... args);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, Args&&... args);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared();
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(size_t N, const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, size_t N,
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared_for_overwrite();
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared_for_overwrite(const A& a);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared_for_overwrite(size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared_for_overwrite(const A& a, size_t N);
@[`constexpr`]{.add}@ bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
@[`constexpr`]{.add}@ strong_ordering operator<=>(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
@[`constexpr`]{.add}@ bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;
@[`constexpr`]{.add}@ strong_ordering operator<=>(const shared_ptr<T>& x, nullptr_t) noexcept;
@[`constexpr`]{.add}@ void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> static_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> dynamic_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> const_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ D* get_deleter(const shared_ptr<T>& p) noexcept;
template<class T> @[`constexpr`]{.add}@ void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
@[`constexpr`]{.add}@ auto out_ptr(Smart& s, Args&&... args);
@[`constexpr`]{.add}@ auto inout_ptr(Smart& s, Args&&... args);
```

Add to [unique.ptr.special]{.sref} (Specialized algorithms):

```
@[`constexpr`]{.add}@ bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ compare_three_way_result_t<typename unique_ptr<T1, D1>::pointer,
```

Add to [util.smartptr.weak.bad]{.sref} (Class `bad_weak_ptr`):

```
@[`constexpr`]{.add}@ const char* what() const noexcept override;
@[`constexpr`]{.add}@ const char* what() const noexcept override;
```

Add to [util.smartptr.shared.general]{.sref} (General):

```
@[`constexpr`]{.add}@ explicit shared_ptr(Y* p);
@[`constexpr`]{.add}@ shared_ptr(Y* p, D d);
@[`constexpr`]{.add}@ shared_ptr(Y* p, D d, A a);
@[`constexpr`]{.add}@ shared_ptr(nullptr_t p, D d);
@[`constexpr`]{.add}@ shared_ptr(nullptr_t p, D d, A a);
template<class Y> @[`constexpr`]{.add}@ shared_ptr(const shared_ptr<Y>& r, element_type* p) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(shared_ptr<Y>&& r, element_type* p) noexcept;
@[`constexpr`]{.add}@ shared_ptr(const shared_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr(shared_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(shared_ptr<Y>&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ explicit shared_ptr(const weak_ptr<Y>& r);
@[`constexpr`]{.add}@ shared_ptr(unique_ptr<Y, D>&& r);
@[`constexpr`]{.add}@ ~shared_ptr();
@[`constexpr`]{.add}@ shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr& operator=(unique_ptr<Y, D>&& r);
@[`constexpr`]{.add}@ void swap(shared_ptr& r) noexcept;
@[`constexpr`]{.add}@ void reset() noexcept;
@[`constexpr`]{.add}@ void reset(Y* p);
@[`constexpr`]{.add}@ void reset(Y* p, D d);
@[`constexpr`]{.add}@ void reset(Y* p, D d, A a);
@[`constexpr`]{.add}@ element_type* get() const noexcept;
@[`constexpr`]{.add}@ T& operator*() const noexcept;
@[`constexpr`]{.add}@ T* operator->() const noexcept;
@[`constexpr`]{.add}@ element_type& operator[](ptrdiff_t i) const;
@[`constexpr`]{.add}@ long use_count() const noexcept;
@[`constexpr`]{.add}@ explicit operator bool() const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const weak_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const shared_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const weak_ptr<U>& b) const noexcept;
```

Add to [util.smartptr.shared.const]{.sref} (Constructors):

```
template<class Y> @[`constexpr`]{.add}@ explicit shared_ptr(Y* p);
template<class Y, class D> @[`constexpr`]{.add}@ shared_ptr(Y* p, D d);
template<class Y, class D, class A> @[`constexpr`]{.add}@ shared_ptr(Y* p, D d, A a);
template<class D> @[`constexpr`]{.add}@ shared_ptr(nullptr_t p, D d);
template<class D, class A> @[`constexpr`]{.add}@ shared_ptr(nullptr_t p, D d, A a);
template<class Y> @[`constexpr`]{.add}@ shared_ptr(const shared_ptr<Y>& r, element_type* p) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(shared_ptr<Y>&& r, element_type* p) noexcept;
@[`constexpr`]{.add}@ shared_ptr(const shared_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr(shared_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(shared_ptr<Y>&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ explicit shared_ptr(const weak_ptr<Y>& r);
template<class Y, class D> @[`constexpr`]{.add}@ shared_ptr(unique_ptr<Y, D>&& r);
```

Add to [util.smartptr.shared.dest]{.sref} (Destructor):

```
@[`constexpr`]{.add}@ ~shared_ptr();
```

Add to [util.smartptr.shared.assign]{.sref} (Assignment):

```
@[`constexpr`]{.add}@ shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
template<class Y, class D> @[`constexpr`]{.add}@ shared_ptr& operator=(unique_ptr<Y, D>&& r);
```

Add to [util.smartptr.shared.mod]{.sref} (Modifiers):

```
@[`constexpr`]{.add}@ void swap(shared_ptr& r) noexcept;
@[`constexpr`]{.add}@ void reset() noexcept;
template<class Y> @[`constexpr`]{.add}@ void reset(Y* p);
template<class Y, class D> @[`constexpr`]{.add}@ void reset(Y* p, D d);
template<class Y, class D, class A> @[`constexpr`]{.add}@ void reset(Y* p, D d, A a);
```

Add to [util.smartptr.shared.obs]{.sref} (Observers):

```
@[`constexpr`]{.add}@ element_type* get() const noexcept;
@[`constexpr`]{.add}@ T& operator*() const noexcept;
@[`constexpr`]{.add}@ T* operator->() const noexcept;
@[`constexpr`]{.add}@ element_type& operator[](ptrdiff_t i) const;
@[`constexpr`]{.add}@ long use_count() const noexcept;
@[`constexpr`]{.add}@ explicit operator bool() const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const weak_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const shared_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const weak_ptr<U>& b) const noexcept;
```

Add to [util.smartptr.shared.create]{.sref} (Creation):

```
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(@*argc*@);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, @*argc*@);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared_for_overwrite(@*argc*@);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared_for_overwrite(const A& a, @*argc*@);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(Args&&... args);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, Args&&... args);
@[`constexpr`]{.add}@ make_shared(size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared();
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(size_t N, const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, size_t N, const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared_for_overwrite();
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared_for_overwrite(const A& a);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared_for_overwrite(size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared_for_overwrite(const A& a, size_t N);
```

Add to [util.smartptr.shared.cmp]{.sref} (Comparison):

```
@[`constexpr`]{.add}@ bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
template<class T> @[`constexpr`]{.add}@ bool operator==(const shared_ptr<T>& a, nullptr_t) noexcept;
@[`constexpr`]{.add}@ strong_ordering operator<=>(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
@[`constexpr`]{.add}@ strong_ordering operator<=>(const shared_ptr<T>& a, nullptr_t) noexcept;
```

Add to [util.smartptr.shared.spec]{.sref} (Specialized algorithms):

```
@[`constexpr`]{.add}@ void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
```

Add to [util.smartptr.shared.cast]{.sref} (Casts):

```
@[`constexpr`]{.add}@ shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> static_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> dynamic_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> const_pointer_cast(shared_ptr<U>&& r) noexcept;
```

Add to [util.smartptr.getdeleter]{.sref} (`get_deleter`):

```
@[`constexpr`]{.add}@ D* get_deleter(const shared_ptr<T>& p) noexcept;
```

Add to [util.smartptr.weak.general]{.sref} (General):

```
@[`constexpr`]{.add}@ weak_ptr(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr(const weak_ptr& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr(const weak_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr(weak_ptr&& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr(weak_ptr<Y>&& r) noexcept;
@[`constexpr`]{.add}@ ~weak_ptr();
@[`constexpr`]{.add}@ weak_ptr& operator=(const weak_ptr& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr& operator=(weak_ptr&& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;
@[`constexpr`]{.add}@ void swap(weak_ptr& r) noexcept;
@[`constexpr`]{.add}@ void reset() noexcept;
@[`constexpr`]{.add}@ long use_count() const noexcept;
@[`constexpr`]{.add}@ bool expired() const noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> lock() const noexcept;
@[`constexpr`]{.add}@ bool owner_before(const shared_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_before(const weak_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const shared_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const weak_ptr<U>& b) const noexcept;
```

Add to [util.smartptr.weak.const]{.sref} (Constructors):

```
@[`constexpr`]{.add}@ weak_ptr(const weak_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr(const weak_ptr<Y>& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr(weak_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr(weak_ptr<Y>&& r) noexcept;
```

Add to [util.smartptr.weak.dest]{.sref} (Destructor):

```
@[`constexpr`]{.add}@ ~weak_ptr();
```

Add to [util.smartptr.weak.assign]{.sref} (Assignment):

```
@[`constexpr`]{.add}@ weak_ptr& operator=(const weak_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr& operator=(weak_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;
```

Add to [util.smartptr.weak.mod]{.sref} (Modifiers):

```
@[`constexpr`]{.add}@ void swap(weak_ptr& r) noexcept;
@[`constexpr`]{.add}@ void reset() noexcept;
```

Add to [util.smartptr.weak.obs]{.sref} (Observers):

```
@[`constexpr`]{.add}@ long use_count() const noexcept;
@[`constexpr`]{.add}@ bool expired() const noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> lock() const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const weak_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const shared_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const weak_ptr<U>& b) const noexcept;
```

Add to [util.smartptr.weak.spec]{.sref} (Specialized algorithms):

```
@[`constexpr`]{.add}@ void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
```

Add to [util.smartptr.ownerless]{.sref} (Class template `owner_less`):

```
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const shared_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const weak_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const shared_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const weak_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const weak_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const shared_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const shared_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const weak_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const shared_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const weak_ptr<U>&) const noexcept;
```

Add to [util.smartptr.owner.equal]{.sref} (Struct `owner_equal`):

```
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const shared_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const weak_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const shared_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const weak_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>& x, const shared_ptr<U>& y) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>& x, const weak_ptr<U>& y) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>& x, const shared_ptr<U>& y) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>& x, const weak_ptr<U>& y) const noexcept;
```

Add to [util.smartptr.enab]{.sref} (Class template `enable_shared_from_this`):

```
@[`constexpr`]{.add}@ enable_shared_from_this(const enable_shared_from_this&) noexcept;
@[`constexpr`]{.add}@ enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept;
@[`constexpr`]{.add}@ ~enable_shared_from_this();
@[`constexpr`]{.add}@ shared_ptr<T> shared_from_this();
@[`constexpr`]{.add}@ shared_ptr<T const> shared_from_this() const;
@[`constexpr`]{.add}@ weak_ptr<T> weak_from_this() noexcept;
@[`constexpr`]{.add}@ weak_ptr<T const> weak_from_this() const noexcept;
@[`constexpr`]{.add}@ enable_shared_from_this(const enable_shared_from_this<T>&) noexcept;
@[`constexpr`]{.add}@ enable_shared_from_this<T>& operator=(const enable_shared_from_this<T>&) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T>       shared_from_this();
@[`constexpr`]{.add}@ shared_ptr<T const> shared_from_this() const;
@[`constexpr`]{.add}@ weak_ptr<T>       weak_from_this() noexcept;
@[`constexpr`]{.add}@ weak_ptr<T const> weak_from_this() const noexcept;
```

Add to [out.ptr.t]{.sref} (Class template `out_ptr_t`):

```
@[`constexpr`]{.add}@ explicit out_ptr_t(Smart&, Args...);
@[`constexpr`]{.add}@ ~out_ptr_t();
@[`constexpr`]{.add}@ operator Pointer*() const noexcept;
@[`constexpr`]{.add}@ operator void**() const noexcept;
@[`constexpr`]{.add}@ explicit out_ptr_t(Smart& smart, Args... args);
@[`constexpr`]{.add}@ ~out_ptr_t();
@[`constexpr`]{.add}@ operator Pointer*() const noexcept;
@[`constexpr`]{.add}@ operator void**() const noexcept;
```

Add to [out.ptr]{.sref} (Function template `out_ptr`):

```
@[`constexpr`]{.add}@ auto out_ptr(Smart& s, Args&&... args);
```

Add to [inout.ptr.t]{.sref} (Class template `inout_ptr_t`):

```
@[`constexpr`]{.add}@ explicit inout_ptr_t(Smart&, Args...);
@[`constexpr`]{.add}@ ~inout_ptr_t();
@[`constexpr`]{.add}@ operator Pointer*() const noexcept;
@[`constexpr`]{.add}@ operator void**() const noexcept;
@[`constexpr`]{.add}@ explicit inout_ptr_t(Smart& smart, Args... args);
@[`constexpr`]{.add}@ ~inout_ptr_t();
@[`constexpr`]{.add}@ operator Pointer*() const noexcept;
@[`constexpr`]{.add}@ operator void**() const noexcept;
```

Add to [inout.ptr]{.sref} (Function template `inout_ptr`):

```
@[`constexpr`]{.add}@ auto inout_ptr(Smart& s, Args&&... args);
```

