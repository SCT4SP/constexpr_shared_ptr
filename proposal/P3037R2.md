---
title: "`constexpr std::shared_ptr`"
document: P3037R2
date: 2024-03-05
audience: LEWG Library Evolution
author:
  - name: Paul Keir
    email: <graham.keir@gmail.com>
toc: true
toc-depth: 4
---

\pagebreak

# Revision History

  - R2 2024-????????
    - Added wording
    - Removed `constexpr`{.cpp} specification from some functions (see below [here](#maybe-not-now-but-soon))
    - Removed SG7 from Audience (post 2024 Spring meeting in Tokyo)
  - R1 2024-03-05
    - Added a motivating example
    - Included libc++ & MSVC STL in atomic operation considerations
  - R0 2023-11-06
    - Original Proposal

# Introduction

Since the adoption of [@P0784R7] in C++20, constant expressions can include
dynamic memory allocation; yet support for smart pointers extends only to
`std::unique_ptr`{.cpp} (since [@P2273R3] in C++23). As at runtime, smart
pointers can encourage hygienic memory management during constant evaluation;
and with no remaining technical obstacles, parity between runtime and
compile-time support for smart pointers should reflect the increased maturity
of language support for constant expression evaluation.  We therefore propose
that `std::shared_ptr`{.cpp} and appropriate class templates from
[smartptr]{.sref} permit `constexpr`{.cpp} evaluation.

# Motivation and Scope

It is convenient when the same C++ code can be deployed both at runtime and
compile time. Our recent project investigates performance scaling of *parallel*
constant expression evaluation in an experimental Clang compiler [@ClangOz]. As
well as C++17 parallel algorithms, a prototype `constexpr`{.cpp} implementation
of the Khronos SYCL API was utilised, where a SYCL `buffer` class abstracts
over device and/or host memory. In the simplified code excerpt below, the
`std::shared_ptr`{.cpp} data member ensures memory is properly deallocated upon
the `buffer`{.cpp}'s destruction, according to its owner status. This is a
common approach for runtime code, and a `constexpr`{.cpp}
`std::shared_ptr`{.cpp} class implementation helpfully bypasses thoughts of raw
pointers and preprocessor macros. The impact of adding `constexpr`{.cpp}
functionality to the SYCL implementation is therefore minimised.

```cpp
template <class T, int dims = 1>
struct buffer
{
  constexpr buffer(const range<dims> &r)
    : range_{ r }, data_{ new T[r.size()], [this](auto* p){ delete [] p; } } { }

  constexpr buffer(T* hostData, const range<dims>& r)
    : range_{ r }, data_{ hostData, [](auto){} } { }

  const range<dims> range_{};
  std::shared_ptr<T[]> data_{};
};
```

Adopted C++26 proposal [@P2738R1] facilitates a straightforward implementation
of comprehensive `constexpr`{.cpp} support for `std::shared_ptr`{.cpp},
allowing the `get_deleter` member function to operate, given the type erasure
required within the `std::shared_ptr`{.cpp} unary class template. We
furthermore propose that the relational operators of `std::unique_ptr`{.cpp},
which can legally operate on pointers originating from a single allocation
during constant evaluation, should also adopt the `constexpr`{.cpp} specifier.

As with C++23 `constexpr`{.cpp} support for `std::unique_ptr`, bumping the
value `__cpp_lib_constexpr_memory` is our requested feature macro change; yet
in the discussion and implementation presented here, we adopt the macro
`__cpp_lib_constexpr_shared_ptr`{.cpp}.

We below elaborate on points which go beyond the simple addition of the
`constexpr`{.cpp} specifier to the relevant member functions.

## Atomic Operations

The existing `std::shared_ptr`{.cpp} class can operate within a multithreaded
runtime environment. A number of its member functions may therefore be defined
using atomic functions; so ensuring that shared state is updated correctly.
Atomic functions are not qualified as `constexpr`{.cpp}; but as constant
expressions must be evaluated by a single thread, a `constexpr`{.cpp}
`std::shared_ptr`{.cpp} implementation can safely skip calls to atomic
functions through the predication of `std::is_constant_evaluated`{.cpp} (or `if
consteval`). For example, here is a modified function from GCC's libstdc++,
called from `std::shared_ptr::use_count()`{.cpp} and elsewhere:

```cpp
constexpr long
_M_get_use_count() const noexcept
{
#ifdef __cpp_lib_constexpr_shared_ptr
  return std::is_constant_evaluated()
           ? _M_use_count
           : __atomic_load_n(&_M_use_count, __ATOMIC_RELAXED);
#else
  return __atomic_load_n(&_M_use_count, __ATOMIC_RELAXED);
#endif
}
```

The use of atomic intrinsics within Clang's libc++ and MSVC's STL can be
elided similarly. In `__memory/shared_ptr.h`, libc++ makes calls to the atomic
intrinsic `__atomic_load_n`{.cpp}, only via the inline C++ functions
`__libcpp_relaxed_load`{.cpp} and `__libcpp_acquire_load`{.cpp}; while
`__atomic_add_fetch`{.cpp} is accessed only via
`__libcpp_atomic_refcount_increment`{.cpp} and
`__libcpp_atomic_refcount_decrement`{.cpp}. Each of these four functions is
comprised only of return statement pairs, predicated upon *object-like* macros
including `_LIBCPP_HAS_NO_THREADS`{.cpp}; and so could easily be modified to
involve `std::is_constant_evaluated`{.cpp} as above.

In `stl/inc/memory`, the `std::shared_ptr`{.cpp} of MSVC's STL inherits a
`_Ref_count_base` member through `_Ptr_base`. `_Ref_count_base` has two
`_Atomic_counter_t` members (aliases of `unsigned long`{.cpp}), updated
atomically using the `_InterlockedCompareExchange`{.cpp};
`_InterlockedIncrement`{.cpp} (via the macro `_MT_INCR`); or
`_InterlockedDecrement`{.cpp} (via the macro `_MT_DECR`) atomic intrinsics. All
the (five) functions invoking these intrinsics can again make use of
`std::is_constant_evaluated` to avoid the atomic operations.

Adding `constexpr`{.cpp} support to an implementation of
`std::shared_ptr`{.cpp} built directly upon an `std::atomic`{.cpp} instance
would need to take an alternative approach; likely involving the modification
of its `std::atomic`{.cpp} definition.

## Two Memory Allocations

Unlike `std::unique_ptr`, a `std::shared_ptr`{.cpp} must store not only the
managed object, but also the type-erased deleter and allocator, as well as the
number of `std::shared_ptr`{.cpp}s and `std::weak_ptr`{.cpp}s which own or
refer to the managed object. This information is managed as part of a
dynamically allocated object referred to as the *control block*.

Existing runtime implementations of `std::make_shared`{.cpp},
`std::allocate_shared`{.cpp},  
<!--
the two spaces above at the line's end produce a newline
-->
`std::make_shared_for_overwrite`{.cpp}, and
`std::allocate_shared_for_overwrite`{.cpp}, allocate memory for both the
control block, *and* the managed object, from a single dynamic memory
allocation; via `reinterpret_cast`{.cpp}.  This practise aligns with a remark
at [util.smartptr.shared.create]{.sref}; quoted below:

  - [7.1]{.pnum} Implementations should perform no more than one memory allocation.
  - [*Note 1*: This provides efficiency equivalent to an intrusive smart pointer.  â€” *end note*]

As `reinterpret_cast`{.cpp} is not permitted within a constant expression, an
alternative approach is required for `std::make_shared`,
`std::allocate_shared`, `std::make_shared_for_overwrite`, and  
<!--
the two spaces above at the line's end produce a newline
-->
`std::allocate_shared_for_overwrite`.  A straightforward solution is to create
the object first, and pass its address to the appropriate
`std::shared_ptr`{.cpp} constructor. Considering the control block, this
approach amounts to two dynamic memory allocations; albeit at compile-time.
Assuming that the runtime implementation need not change, the remark quoted
above can be left unchanged; as this is only a recommendation, not a
requirement.

## Relational Operators

Comparing dynamically allocated pointers within a constant expression is legal,
provided the result of the comparison is not unspecified.  Such comparisons are
defined in terms of a partial order, applicable to pointers which either point
"to different elements of the same array, or to subobjects thereof"; or to
"different non-static data members of the same object, or to subobjects of such
members, recursively..."; from paragraph 4 of [expr.rel]{.sref}. A simple
example program is shown below:

```cpp
constexpr bool ptr_compare()
{
  int* p = new int[2]{};
  bool b = &p[0] < &p[1];
  delete [] p;
  return b;
}

static_assert(ptr_compare());
```

It is therefore unsurprising that we include the `std::shared_ptr`{.cpp}
relational operators within the scope of our proposal to apply
`constexpr`{.cpp} to all functions within [smartptr]{.sref}; the
`std::shared_ptr`{.cpp} aliasing constructor makes this especially simple to
configure:

```cpp
constexpr bool sptr_compare()
{
  double *arr = new double[2];
  std::shared_ptr p{&arr[0]}, q{p, p.get() + 1};
  return p < q;
}

static_assert(sptr_compare());
```

Furthermore, in the interests of `constexpr`{.cpp} consistency, we propose that
the relational operators of `std::unique_ptr`{.cpp} *also* now include support
for constant evaluation. As discussed above, the results of such comparisons
are very often well defined.

It may be argued that a `std::unique_ptr`{.cpp} which is the sole owner of an
array, or an object with data members, presents less need for relational
operators. Yet we must consider that a custom deleter can easily change the
operational semantics; as demonstrated in the example below. A
`std::unique_ptr`{.cpp} should also be legally comparable with itself.

```cpp
constexpr bool uptr_compare()
{
  short* p = new short[2]{};
  auto del = [](short*){};
  std::unique_ptr<short[]>               a{p+0};
  std::unique_ptr<short[],decltype(del)> b{p+1, del};
  return a < b;
}

static_assert(uptr_compare());
```

## Maybe Not Now, But Soon

The functions from [smartptr]{.sref} listed below cannot possibly be evaluated
within a constant expression. We *do not* propose that their specifications
should change. While C++23's [@P2448R2] allows such functions to be annotated
as `constexpr`{.cpp}, we suggest that in this instance the C++ community will
be served better by a future update; when their constant evaluation becomes
possible.

  * [util.smartptr.weak.bad]{.sref}: `std::bad_weak_ptr`{.cpp} cannot be constructed as it inherits from a class, `std::exception`, which has no `constexpr`{.cpp} member functions.
  * [util.smartptr.hash]{.sref}: The `operator()` member of the class template specialisations for `std::hash<std::unique_ptr<T,D>>` and `std::hash<std::shared_ptr<T>>` cannot be defined according to the *Cpp17Hash* requirements ([hash.requirements]{.sref}). (A pointer cannot, during constant evaluation, be converted to an `std::size_t` using `reinterpret_cast`{.cpp}; or otherwise.)
  * [util.smartptr.owner.hash]{.sref}: The two `operator()` member functions of the recently adopted `owner_hash` class, also cannot be defined according to the *Cpp17Hash* requirements.
  * [util.smartptr.shared.obs]{.sref}: The recently adopted `owner_hash()` member function of `std::shared_ptr`, also cannot be defined according to the *Cpp17Hash* requirements.
  * [util.smartptr.weak.obs]{.sref}: The recently adopted `owner_hash()` member function of `std::weak_ptr`, also cannot be defined according to the *Cpp17Hash* requirements.

We also *do not* propose any specification change for the overloads of
`operator<<`{.cpp} for `std::shared_ptr`{.cpp} and `std::unique_ptr`{.cpp},
from [util.smartptr.shared.io]{.sref} and [unique.ptr.io]{.sref}. Unlike the
functions above, a `constexpr`{.cpp} implementation for these
`operator<<`{.cpp} overloads could today use a vendor-specific extension; do
nothing; or simply rely on an error message. But such possibilities should be
discussed in a separate proposal focused on IO.

# Impact on the Standard

This proposal is a pure library extension, and does not require any new language features.

# Implementation

An implementation based on the GNU C++ Library (libstdc++) can be found
[here](https://github.com/SCT4SP/constexpr_shared_ptr). A comprehensive test
suite is included there within `tests/shared_ptr_constexpr_tests.cpp`;
alongside a standalone bash script to run it. All tests pass with recent GCC
and Clang (i.e. versions supporting [@P2738R1]; `__cpp_constexpr >= 202306L`).

# Proposed Wording

Add to [version.syn]{.sref} [@N4981]:

```diff
- #define __cpp_lib_constexpr_memory                  202202L // freestanding, also in <memory>
+ #define __cpp_lib_constexpr_memory                  YYYYMML // freestanding, also in <memory>
```

```
[-\rSec0[mem]{Memory-]{+\rSecX0[mem]{Memory+} management library}
[-\rSec1[mem.general]{General}-]{+\rSecX1[mem.general]{General}+}
[-\rSec1[memory]{Memory}-]{+\rSecX1[memory]{Memory}+}
[-\rSec2[memory.general]{In-]{+\rSecX2[memory.general]{In+} general}
[-\rSec2[memory.syn]{Header-]{+\rSecX2[memory.syn]{Header+} \tcode{<memory>} synopsis}
@[`constexpr`]{.add}@ bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ compare_three_way_result_t<typename unique_ptr<T1, D1>::pointer,
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(Args&&... args);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, Args&&... args);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared();
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(size_t N, const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, size_t N,
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared_for_overwrite();
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared_for_overwrite(const A& a);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared_for_overwrite(size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared_for_overwrite(const A& a, size_t N);
@[`constexpr`]{.add}@ bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
@[`constexpr`]{.add}@ strong_ordering operator<=>(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
@[`constexpr`]{.add}@ bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;
@[`constexpr`]{.add}@ strong_ordering operator<=>(const shared_ptr<T>& x, nullptr_t) noexcept;
@[`constexpr`]{.add}@ void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> static_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> dynamic_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> const_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> reinterpret_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> reinterpret_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ D* get_deleter(const shared_ptr<T>& p) noexcept;
template<class T> @[`constexpr`]{.add}@ void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
@[`constexpr`]{.add}@ auto out_ptr(Smart& s, Args&&... args);
@[`constexpr`]{.add}@ auto inout_ptr(Smart& s, Args&&... args);
[-\rSec2[pointer.traits]{Pointer-]{+\rSecX2[pointer.traits]{Pointer+} traits}
[-\rSec3[pointer.traits.general]{General}-]{+\rSecX3[pointer.traits.general]{General}+}
[-\rSec3[pointer.traits.types]{Member-]{+\rSecX3[pointer.traits.types]{Member+} types}
[-\rSec3[pointer.traits.functions]{Member-]{+\rSecX3[pointer.traits.functions]{Member+} functions}
[-\rSec3[pointer.traits.optmem]{Optional-]{+\rSecX3[pointer.traits.optmem]{Optional+} members}
[-\rSec2[pointer.conversion]{Pointer-]{+\rSecX2[pointer.conversion]{Pointer+} conversion}
[-\rSec2[ptr.align]{Pointer-]{+\rSecX2[ptr.align]{Pointer+} alignment}
[-\rSec2[obj.lifetime]{Explicit-]{+\rSecX2[obj.lifetime]{Explicit+} lifetime management}
[-\rSec2[allocator.tag]{Allocator-]{+\rSecX2[allocator.tag]{Allocator+} argument tag}
[-\rSec2[allocator.uses]{\tcode{uses_allocator}}-]{+\rSecX2[allocator.uses]{\tcode{uses_allocator}}+}
[-\rSec3[allocator.uses.trait]{\tcode{uses_allocator}-]{+\rSecX3[allocator.uses.trait]{\tcode{uses_allocator}+} trait}
[-\rSec3[allocator.uses.construction]{Uses-allocator-]{+\rSecX3[allocator.uses.construction]{Uses-allocator+} construction}
[-\rSec2[allocator.traits]{Allocator-]{+\rSecX2[allocator.traits]{Allocator+} traits}
[-\rSec3[allocator.traits.general]{General}-]{+\rSecX3[allocator.traits.general]{General}+}
[-\rSec3[allocator.traits.types]{Member-]{+\rSecX3[allocator.traits.types]{Member+} types}
[-\rSec3[allocator.traits.members]{Static-]{+\rSecX3[allocator.traits.members]{Static+} member functions}
[-\rSec3[allocator.traits.other]{Other}-]{+\rSecX3[allocator.traits.other]{Other}+}
[-\rSec2[default.allocator]{The-]{+\rSecX2[default.allocator]{The+} default allocator}
[-\rSec3[default.allocator.general]{General}-]{+\rSecX3[default.allocator.general]{General}+}
[-\rSec3[allocator.members]{Members}-]{+\rSecX3[allocator.members]{Members}+}
[-\rSec3[allocator.globals]{Operators}-]{+\rSecX3[allocator.globals]{Operators}+}
[-\rSec2[specialized.addressof]{\tcode{addressof}}-]{+\rSecX2[specialized.addressof]{\tcode{addressof}}+}
[-\rSec2[c.malloc]{C-]{+\rSecX2[c.malloc]{C+} library memory allocation}
[-\rSec1[smartptr]{Smart-]{+\rSecX1[smartptr]{Smart+} pointers}
[-\rSec2[unique.ptr]{Unique-ownership-]{+\rSecX2[unique.ptr]{Unique-ownership+} pointers}
[-\rSec3[unique.ptr.general]{General}-]{+\rSecX3[unique.ptr.general]{General}+}
[-\rSec3[unique.ptr.dltr]{Default-]{+\rSecX3[unique.ptr.dltr]{Default+} deleters}
[-\rSec4[unique.ptr.dltr.general]{In-]{+\rSecX4[unique.ptr.dltr.general]{In+} general}
[-\rSec4[unique.ptr.dltr.dflt]{\tcode{default_delete}}-]{+\rSecX4[unique.ptr.dltr.dflt]{\tcode{default_delete}}+}
[-\rSec4[unique.ptr.dltr.dflt1]{\tcode{default_delete<T[]>}}-]{+\rSecX4[unique.ptr.dltr.dflt1]{\tcode{default_delete<T[]>}}+}
[-\rSec3[unique.ptr.single]{\tcode{unique_ptr}-]{+\rSecX3[unique.ptr.single]{\tcode{unique_ptr}+} for single objects}
[-\rSec4[unique.ptr.single.general]{General}-]{+\rSecX4[unique.ptr.single.general]{General}+}
[-\rSec4[unique.ptr.single.ctor]{Constructors}-]{+\rSecX4[unique.ptr.single.ctor]{Constructors}+}
[-\rSec4[unique.ptr.single.dtor]{Destructor}-]{+\rSecX4[unique.ptr.single.dtor]{Destructor}+}
[-\rSec4[unique.ptr.single.asgn]{Assignment}-]{+\rSecX4[unique.ptr.single.asgn]{Assignment}+}
[-\rSec4[unique.ptr.single.observers]{Observers}-]{+\rSecX4[unique.ptr.single.observers]{Observers}+}
[-\rSec4[unique.ptr.single.modifiers]{Modifiers}-]{+\rSecX4[unique.ptr.single.modifiers]{Modifiers}+}
[-\rSec3[unique.ptr.runtime]{\tcode{unique_ptr}-]{+\rSecX3[unique.ptr.runtime]{\tcode{unique_ptr}+} for array objects with a runtime length}
[-\rSec4[unique.ptr.runtime.general]{General}-]{+\rSecX4[unique.ptr.runtime.general]{General}+}
[-\rSec4[unique.ptr.runtime.ctor]{Constructors}-]{+\rSecX4[unique.ptr.runtime.ctor]{Constructors}+}
[-\rSec4[unique.ptr.runtime.asgn]{Assignment}-]{+\rSecX4[unique.ptr.runtime.asgn]{Assignment}+}
[-\rSec4[unique.ptr.runtime.observers]{Observers}-]{+\rSecX4[unique.ptr.runtime.observers]{Observers}+}
[-\rSec4[unique.ptr.runtime.modifiers]{Modifiers}-]{+\rSecX4[unique.ptr.runtime.modifiers]{Modifiers}+}
[-\rSec3[unique.ptr.create]{Creation}-]{+\rSecX3[unique.ptr.create]{Creation}+}
[-\rSec3[unique.ptr.special]{Specialized-]{+\rSecX3[unique.ptr.special]{Specialized+} algorithms}
@[`constexpr`]{.add}@ bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
@[`constexpr`]{.add}@ compare_three_way_result_t<typename unique_ptr<T1, D1>::pointer,
[-\rSec3[unique.ptr.io]{I/O}-]{+\rSecX3[unique.ptr.io]{I/O}+}
[-\rSec2[util.sharedptr]{Shared-ownership-]{+\rSecX2[util.sharedptr]{Shared-ownership+} pointers}
[-\rSec3[util.smartptr.weak.bad]{Class-]{+\rSecX3[util.smartptr.weak.bad]{Class+} \tcode{bad_weak_ptr}}%
[-\rSec3[util.smartptr.shared]{Class-]{+\rSecX3[util.smartptr.shared]{Class+} template \tcode{shared_ptr}}
[-\rSec4[util.smartptr.shared.general]{General}-]{+\rSecX4[util.smartptr.shared.general]{General}+}
@[`constexpr`]{.add}@ explicit shared_ptr(Y* p);
@[`constexpr`]{.add}@ shared_ptr(Y* p, D d);
@[`constexpr`]{.add}@ shared_ptr(Y* p, D d, A a);
@[`constexpr`]{.add}@ shared_ptr(nullptr_t p, D d);
@[`constexpr`]{.add}@ shared_ptr(nullptr_t p, D d, A a);
template<class Y> @[`constexpr`]{.add}@ shared_ptr(const shared_ptr<Y>& r, element_type* p) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(shared_ptr<Y>&& r, element_type* p) noexcept;
@[`constexpr`]{.add}@ shared_ptr(const shared_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr(shared_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(shared_ptr<Y>&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ explicit shared_ptr(const weak_ptr<Y>& r);
@[`constexpr`]{.add}@ shared_ptr(unique_ptr<Y, D>&& r);
@[`constexpr`]{.add}@ ~shared_ptr();
@[`constexpr`]{.add}@ shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr& operator=(unique_ptr<Y, D>&& r);
@[`constexpr`]{.add}@ void swap(shared_ptr& r) noexcept;
@[`constexpr`]{.add}@ void reset() noexcept;
@[`constexpr`]{.add}@ void reset(Y* p);
@[`constexpr`]{.add}@ void reset(Y* p, D d);
@[`constexpr`]{.add}@ void reset(Y* p, D d, A a);
@[`constexpr`]{.add}@ element_type* get() const noexcept;
@[`constexpr`]{.add}@ T& operator*() const noexcept;
@[`constexpr`]{.add}@ T* operator->() const noexcept;
@[`constexpr`]{.add}@ element_type& operator[](ptrdiff_t i) const;
@[`constexpr`]{.add}@ long use_count() const noexcept;
@[`constexpr`]{.add}@ explicit operator bool() const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const weak_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const shared_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const weak_ptr<U>& b) const noexcept;
[-\rSec4[util.smartptr.shared.const]{Constructors}-]{+\rSecX4[util.smartptr.shared.const]{Constructors}+}
template<class Y> @[`constexpr`]{.add}@ explicit shared_ptr(Y* p);
template<class Y, class D> @[`constexpr`]{.add}@ shared_ptr(Y* p, D d);
template<class Y, class D, class A> @[`constexpr`]{.add}@ shared_ptr(Y* p, D d, A a);
template<class D> @[`constexpr`]{.add}@ shared_ptr(nullptr_t p, D d);
template<class D, class A> @[`constexpr`]{.add}@ shared_ptr(nullptr_t p, D d, A a);
template<class Y> @[`constexpr`]{.add}@ shared_ptr(const shared_ptr<Y>& r, element_type* p) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(shared_ptr<Y>&& r, element_type* p) noexcept;
@[`constexpr`]{.add}@ shared_ptr(const shared_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr(shared_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr(shared_ptr<Y>&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ explicit shared_ptr(const weak_ptr<Y>& r);
template<class Y, class D> @[`constexpr`]{.add}@ shared_ptr(unique_ptr<Y, D>&& r);
[-\rSec4[util.smartptr.shared.dest]{Destructor}-]{+\rSecX4[util.smartptr.shared.dest]{Destructor}+}
@[`constexpr`]{.add}@ ~shared_ptr();
[-\rSec4[util.smartptr.shared.assign]{Assignment}-]{+\rSecX4[util.smartptr.shared.assign]{Assignment}+}
@[`constexpr`]{.add}@ shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
template<class Y, class D> @[`constexpr`]{.add}@ shared_ptr& operator=(unique_ptr<Y, D>&& r);
[-\rSec4[util.smartptr.shared.mod]{Modifiers}-]{+\rSecX4[util.smartptr.shared.mod]{Modifiers}+}
@[`constexpr`]{.add}@ void swap(shared_ptr& r) noexcept;
@[`constexpr`]{.add}@ void reset() noexcept;
template<class Y> @[`constexpr`]{.add}@ void reset(Y* p);
template<class Y, class D> @[`constexpr`]{.add}@ void reset(Y* p, D d);
template<class Y, class D, class A> @[`constexpr`]{.add}@ void reset(Y* p, D d, A a);
[-\rSec4[util.smartptr.shared.obs]{Observers}-]{+\rSecX4[util.smartptr.shared.obs]{Observers}+}
@[`constexpr`]{.add}@ element_type* get() const noexcept;
@[`constexpr`]{.add}@ T& operator*() const noexcept;
@[`constexpr`]{.add}@ T* operator->() const noexcept;
@[`constexpr`]{.add}@ element_type& operator[](ptrdiff_t i) const;
@[`constexpr`]{.add}@ long use_count() const noexcept;
@[`constexpr`]{.add}@ explicit operator bool() const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const weak_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const shared_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const weak_ptr<U>& b) const noexcept;
[-\rSec4[util.smartptr.shared.create]{Creation}-]{+\rSecX4[util.smartptr.shared.create]{Creation}+}
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(@\placeholdernc{args}@);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, @\placeholdernc{args}@);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared_for_overwrite(@\placeholdernc{args}@);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared_for_overwrite(const A& a, @\placeholdernc{args}@);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(Args&&... args);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, Args&&... args);
@[`constexpr`]{.add}@ make_shared(size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared();
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(size_t N, const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, size_t N, const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared(const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared(const A& a, const remove_extent_t<T>& u);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared_for_overwrite();
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared_for_overwrite(const A& a);
@[`constexpr`]{.add}@ shared_ptr<T> make_shared_for_overwrite(size_t N);
@[`constexpr`]{.add}@ shared_ptr<T> allocate_shared_for_overwrite(const A& a, size_t N);
[-\rSec4[util.smartptr.shared.cmp]{Comparison}-]{+\rSecX4[util.smartptr.shared.cmp]{Comparison}+}
@[`constexpr`]{.add}@ bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
template<class T> @[`constexpr`]{.add}@ bool operator==(const shared_ptr<T>& a, nullptr_t) noexcept;
@[`constexpr`]{.add}@ strong_ordering operator<=>(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
@[`constexpr`]{.add}@ strong_ordering operator<=>(const shared_ptr<T>& a, nullptr_t) noexcept;
[-\rSec4[util.smartptr.shared.spec]{Specialized-]{+\rSecX4[util.smartptr.shared.spec]{Specialized+} algorithms}
@[`constexpr`]{.add}@ void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
[-\rSec4[util.smartptr.shared.cast]{Casts}-]{+\rSecX4[util.smartptr.shared.cast]{Casts}+}
@[`constexpr`]{.add}@ shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> static_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> dynamic_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> const_pointer_cast(shared_ptr<U>&& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> reinterpret_pointer_cast(const shared_ptr<U>& r) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> reinterpret_pointer_cast(shared_ptr<U>&& r) noexcept;
[-\rSec4[util.smartptr.getdeleter]{\tcode{get_deleter}}-]{+\rSecX4[util.smartptr.getdeleter]{\tcode{get_deleter}}+}
@[`constexpr`]{.add}@ D* get_deleter(const shared_ptr<T>& p) noexcept;
[-\rSec4[util.smartptr.shared.io]{I/O}-]{+\rSecX4[util.smartptr.shared.io]{I/O}+}
[-\rSec3[util.smartptr.weak]{Class-]{+\rSecX3[util.smartptr.weak]{Class+} template \tcode{weak_ptr}}
[-\rSec4[util.smartptr.weak.general]{General}-]{+\rSecX4[util.smartptr.weak.general]{General}+}
@[`constexpr`]{.add}@ weak_ptr(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr(const weak_ptr& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr(const weak_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr(weak_ptr&& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr(weak_ptr<Y>&& r) noexcept;
@[`constexpr`]{.add}@ ~weak_ptr();
@[`constexpr`]{.add}@ weak_ptr& operator=(const weak_ptr& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr& operator=(weak_ptr&& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;
@[`constexpr`]{.add}@ void swap(weak_ptr& r) noexcept;
@[`constexpr`]{.add}@ void reset() noexcept;
@[`constexpr`]{.add}@ long use_count() const noexcept;
@[`constexpr`]{.add}@ bool expired() const noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> lock() const noexcept;
@[`constexpr`]{.add}@ bool owner_before(const shared_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_before(const weak_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const shared_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const weak_ptr<U>& b) const noexcept;
[-\rSec4[util.smartptr.weak.const]{Constructors}-]{+\rSecX4[util.smartptr.weak.const]{Constructors}+}
@[`constexpr`]{.add}@ weak_ptr(const weak_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr(const weak_ptr<Y>& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr(weak_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr(weak_ptr<Y>&& r) noexcept;
[-\rSec4[util.smartptr.weak.dest]{Destructor}-]{+\rSecX4[util.smartptr.weak.dest]{Destructor}+}
@[`constexpr`]{.add}@ ~weak_ptr();
[-\rSec4[util.smartptr.weak.assign]{Assignment}-]{+\rSecX4[util.smartptr.weak.assign]{Assignment}+}
@[`constexpr`]{.add}@ weak_ptr& operator=(const weak_ptr& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;
@[`constexpr`]{.add}@ weak_ptr& operator=(weak_ptr&& r) noexcept;
template<class Y> @[`constexpr`]{.add}@ weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;
[-\rSec4[util.smartptr.weak.mod]{Modifiers}-]{+\rSecX4[util.smartptr.weak.mod]{Modifiers}+}
@[`constexpr`]{.add}@ void swap(weak_ptr& r) noexcept;
@[`constexpr`]{.add}@ void reset() noexcept;
[-\rSec4[util.smartptr.weak.obs]{Observers}-]{+\rSecX4[util.smartptr.weak.obs]{Observers}+}
@[`constexpr`]{.add}@ long use_count() const noexcept;
@[`constexpr`]{.add}@ bool expired() const noexcept;
@[`constexpr`]{.add}@ shared_ptr<T> lock() const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U> @[`constexpr`]{.add}@ bool owner_before(const weak_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const shared_ptr<U>& b) const noexcept;
@[`constexpr`]{.add}@ bool owner_equal(const weak_ptr<U>& b) const noexcept;
[-\rSec4[util.smartptr.weak.spec]{Specialized-]{+\rSecX4[util.smartptr.weak.spec]{Specialized+} algorithms}
@[`constexpr`]{.add}@ void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
[-\rSec3[util.smartptr.ownerless]{Class-]{+\rSecX3[util.smartptr.ownerless]{Class+} template \tcode{owner_less}}
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const shared_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const weak_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const shared_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const weak_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const weak_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const shared_ptr<T>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const shared_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const weak_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const shared_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const weak_ptr<U>&) const noexcept;
[-\rSec3[util.smartptr.owner.hash]{Struct-]{+\rSecX3[util.smartptr.owner.hash]{Struct+} \tcode{owner_hash}}
[-\rSec3[util.smartptr.owner.equal]{Struct-]{+\rSecX3[util.smartptr.owner.equal]{Struct+} \tcode{owner_equal}}
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const shared_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>&, const weak_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const shared_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>&, const weak_ptr<U>&) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>& x, const shared_ptr<U>& y) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const shared_ptr<T>& x, const weak_ptr<U>& y) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>& x, const shared_ptr<U>& y) const noexcept;
@[`constexpr`]{.add}@ bool operator()(const weak_ptr<T>& x, const weak_ptr<U>& y) const noexcept;
[-\rSec3[util.smartptr.enab]{Class-]{+\rSecX3[util.smartptr.enab]{Class+} template \tcode{enable_shared_from_this}}
@[`constexpr`]{.add}@ enable_shared_from_this(const enable_shared_from_this&) noexcept;
@[`constexpr`]{.add}@ enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept;
@[`constexpr`]{.add}@ ~enable_shared_from_this();
@[`constexpr`]{.add}@ shared_ptr<T> shared_from_this();
@[`constexpr`]{.add}@ shared_ptr<T const> shared_from_this() const;
@[`constexpr`]{.add}@ weak_ptr<T> weak_from_this() noexcept;
@[`constexpr`]{.add}@ weak_ptr<T const> weak_from_this() const noexcept;
@[`constexpr`]{.add}@ enable_shared_from_this(const enable_shared_from_this<T>&) noexcept;
@[`constexpr`]{.add}@ enable_shared_from_this<T>& operator=(const enable_shared_from_this<T>&) noexcept;
@[`constexpr`]{.add}@ shared_ptr<T>       shared_from_this();
@[`constexpr`]{.add}@ shared_ptr<T const> shared_from_this() const;
@[`constexpr`]{.add}@ weak_ptr<T>       weak_from_this() noexcept;
@[`constexpr`]{.add}@ weak_ptr<T const> weak_from_this() const noexcept;
[-\rSec2[util.smartptr.hash]{Smart-]{+\rSecX2[util.smartptr.hash]{Smart+} pointer hash support}
[-\rSec2[smartptr.adapt]{Smart-]{+\rSecX2[smartptr.adapt]{Smart+} pointer adaptors}
[-\rSec3[out.ptr.t]{Class-]{+\rSecX3[out.ptr.t]{Class+} template \tcode{out_ptr_t}}
@[`constexpr`]{.add}@ explicit out_ptr_t(Smart&, Args...);
@[`constexpr`]{.add}@ ~out_ptr_t();
@[`constexpr`]{.add}@ operator Pointer*() const noexcept;
@[`constexpr`]{.add}@ operator void**() const noexcept;
@[`constexpr`]{.add}@ explicit out_ptr_t(Smart& smart, Args... args);
@[`constexpr`]{.add}@ ~out_ptr_t();
@[`constexpr`]{.add}@ operator Pointer*() const noexcept;
@[`constexpr`]{.add}@ operator void**() const noexcept;
[-\rSec3[out.ptr]{Function-]{+\rSecX3[out.ptr]{Function+} template \tcode{out_ptr}}
@[`constexpr`]{.add}@ auto out_ptr(Smart& s, Args&&... args);
[-\rSec3[inout.ptr.t]{Class-]{+\rSecX3[inout.ptr.t]{Class+} template \tcode{inout_ptr_t}}
@[`constexpr`]{.add}@ explicit inout_ptr_t(Smart&, Args...);
@[`constexpr`]{.add}@ ~inout_ptr_t();
@[`constexpr`]{.add}@ operator Pointer*() const noexcept;
@[`constexpr`]{.add}@ operator void**() const noexcept;
@[`constexpr`]{.add}@ explicit inout_ptr_t(Smart& smart, Args... args);
@[`constexpr`]{.add}@ ~inout_ptr_t();
@[`constexpr`]{.add}@ operator Pointer*() const noexcept;
@[`constexpr`]{.add}@ operator void**() const noexcept;
[-\rSec3[inout.ptr]{Function-]{+\rSecX3[inout.ptr]{Function+} template \tcode{inout_ptr}}
@[`constexpr`]{.add}@ auto inout_ptr(Smart& s, Args&&... args);
[-\rSec1[mem.res]{Memory-]{+\rSecX1[mem.res]{Memory+} resources}
[-\rSec2[mem.res.syn]{Header-]{+\rSecX2[mem.res.syn]{Header+} \tcode{<memory_resource>} synopsis}
[-\rSec2[mem.res.class]{Class-]{+\rSecX2[mem.res.class]{Class+} \tcode{memory_resource}}
[-\rSec3[mem.res.class.general]{General}-]{+\rSecX3[mem.res.class.general]{General}+}
[-\rSec3[mem.res.public]{Public-]{+\rSecX3[mem.res.public]{Public+} member functions}
[-\rSec3[mem.res.private]{Private-]{+\rSecX3[mem.res.private]{Private+} virtual member functions}
[-\rSec3[mem.res.eq]{Equality}-]{+\rSecX3[mem.res.eq]{Equality}+}
[-\rSec2[mem.poly.allocator.class]{Class-]{+\rSecX2[mem.poly.allocator.class]{Class+} template \tcode{polymorphic_allocator}}
[-\rSec3[mem.poly.allocator.class.general]{General}-]{+\rSecX3[mem.poly.allocator.class.general]{General}+}
[-\rSec3[mem.poly.allocator.ctor]{Constructors}-]{+\rSecX3[mem.poly.allocator.ctor]{Constructors}+}
[-\rSec3[mem.poly.allocator.mem]{Member-]{+\rSecX3[mem.poly.allocator.mem]{Member+} functions}
[-\rSec3[mem.poly.allocator.eq]{Equality}-]{+\rSecX3[mem.poly.allocator.eq]{Equality}+}
[-\rSec2[mem.res.global]{Access-]{+\rSecX2[mem.res.global]{Access+} to program-wide \tcode{memory_resource} objects}
[-\rSec2[mem.res.pool]{Pool-]{+\rSecX2[mem.res.pool]{Pool+} resource classes}
[-\rSec3[mem.res.pool.overview]{Classes-]{+\rSecX3[mem.res.pool.overview]{Classes+} \tcode{synchronized_pool_resource} and \tcode{unsynchronized_pool_resource}}
[-\rSec3[mem.res.pool.options]{\tcode{pool_options}-]{+\rSecX3[mem.res.pool.options]{\tcode{pool_options}+} data members}
[-\rSec3[mem.res.pool.ctor]{Constructors-]{+\rSecX3[mem.res.pool.ctor]{Constructors+} and destructors}
[-\rSec3[mem.res.pool.mem]{Members}-]{+\rSecX3[mem.res.pool.mem]{Members}+}
[-\rSec2[mem.res.monotonic.buffer]{Class-]{+\rSecX2[mem.res.monotonic.buffer]{Class+} \tcode{monotonic_buffer_resource}}
[-\rSec3[mem.res.monotonic.buffer.general]{General}-]{+\rSecX3[mem.res.monotonic.buffer.general]{General}+}
[-\rSec3[mem.res.monotonic.buffer.ctor]{Constructors-]{+\rSecX3[mem.res.monotonic.buffer.ctor]{Constructors+} and destructor}
[-\rSec3[mem.res.monotonic.buffer.mem]{Members}-]{+\rSecX3[mem.res.monotonic.buffer.mem]{Members}+}
[-\rSec1[allocator.adaptor]{Class-]{+\rSecX1[allocator.adaptor]{Class+} template \tcode{scoped_allocator_adaptor}}
[-\rSec2[allocator.adaptor.syn]{Header-]{+\rSecX2[allocator.adaptor.syn]{Header+} \tcode{<scoped_allocator>} synopsis}
[-\rSec2[allocator.adaptor.types]{Member-]{+\rSecX2[allocator.adaptor.types]{Member+} types}
[-\rSec2[allocator.adaptor.cnstr]{Constructors}-]{+\rSecX2[allocator.adaptor.cnstr]{Constructors}+}
[-\rSec2[allocator.adaptor.members]{Members}-]{+\rSecX2[allocator.adaptor.members]{Members}+}
[-\rSec2[scoped.adaptor.operators]{Operators}-]{+\rSecX2[scoped.adaptor.operators]{Operators}+}
```

Add to [smartptr]{.sref} [@N4981]:

# Acknowledgements

Thanks to all of the following:

  - (In alphabetical order by last name.) Thiago Macieira, Arthur O'Dwyer,
    Jonathan Wakely and everyone else who contributed to the online forum
    discussions.

\pagebreak

---
references:
  - id: P0784R7
    citation-label: P0784R7
    title: "More constexpr containers"
    author:
      family: Dimov
      given: Peter
      family: Dionne
      given: Louis
      family: Ranns
      given: Nina
      family: Smith
      given: Richard
      family: Vandevoorde
      given: Daveed
    issued:
      year: 2019
    URL: https://wg21.link/p0784

  - id: P2738R1
    citation-label: P2738R1
    title: "`constexpr` cast from `void*`: towards `constexpr` type-erasure"
    author:
      family: Jabot
      given: Corentin
      family: Ledger
      given: David
    issued:
      year: 2023
    URL: https://wg21.link/p2738

  - id: P2448R2
    citation-label: P2448R2
    title: "Relaxing some `constexpr`{.cpp} restrictions"
    author:
      family: Revzin
      given: Barry
    issued:
      year: 2022
    URL: https://wg21.link/p2448

  - id: P2273R3
    citation-label: P2273R3
    title: "Making `std::unique_ptr` constexpr"
    author:
      family: Fertig
      given: Andreas
    issued:
      year: 2021
    URL: https://wg21.link/p2273

  - id: ClangOz
    citation-label: ClangOz
    title: "Performance Analysis of Compiler Support for Parallel Evaluation of C++ Constant Expressions"
    author:
      family: Gozillon
      given: Andrew
      family: Haeri
      given: Hossein
      family: Riordan
      given: James
      family: Keir
      given: Paul
    issued:
      year: 2024
    URL: https://doi.org/10.1007/978-3-031-51075-5_6
---
