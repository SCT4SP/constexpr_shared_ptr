\documentclass[11pt]{article}

\usepackage{color}
\usepackage{xcolor}
\usepackage{fullpage}
\usepackage[colorlinks, allcolors=blue]{hyperref}
\usepackage{listings}
\usepackage{parskip}
\usepackage{url}
\usepackage{courier}
\usepackage[T1]{fontenc}
% \usepackage{libertine}%% Only as example for the romans/sans fonts
\usepackage[scaled=0.85]{beramono}
\usepackage{changepage}
\usepackage{nameref}

% Solarized colour scheme for listings
\definecolor{solarized@base03}{HTML}{002B36}
\definecolor{solarized@base02}{HTML}{073642}
\definecolor{solarized@base01}{HTML}{586e75}
\definecolor{solarized@base00}{HTML}{657b83}
\definecolor{solarized@base0}{HTML}{839496}
\definecolor{solarized@base1}{HTML}{93a1a1}
\definecolor{solarized@base2}{HTML}{EEE8D5}
\definecolor{solarized@base3}{HTML}{FDF6E3}
\definecolor{solarized@yellow}{HTML}{B58900}
\definecolor{solarized@orange}{HTML}{CB4B16}
\definecolor{solarized@red}{HTML}{DC322F}
\definecolor{solarized@magenta}{HTML}{D33682}
\definecolor{solarized@violet}{HTML}{6C71C4}
\definecolor{solarized@blue}{HTML}{268BD2}
\definecolor{solarized@cyan}{HTML}{2AA198}
\definecolor{solarized@green}{HTML}{859900}

\lstset{
  basicstyle=\footnotesize\ttfamily,
}

% Define C++ syntax highlighting colour scheme
\lstdefinelanguage{cpp}{
  language=C++,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  numberstyle=\footnotesize,
  tabsize=2,
  breaklines=true,
  escapeinside={@}{@},
  numberstyle=\tiny\color{solarized@base01},
  keywordstyle=\color{solarized@green},
  stringstyle=\color{solarized@cyan}\ttfamily,
  identifierstyle=\color{solarized@blue},
  commentstyle=\color{solarized@base01},
  emphstyle=\color{solarized@red},
  frame=single,
  rulecolor=\color{solarized@base2},
  rulesepcolor=\color{solarized@base2},
  showstringspaces=false,
}

\lstdefinelanguage{diff}{
  morecomment=[f][\color{blue}]{@@},           % group identifier
  morecomment=[f][\color{red}]{-},             % deleted lines
  morecomment=[f][\color{green!50!black}]{+},  % added lines
  morecomment=[f][\color{magenta}]{---},       % diff header lines
  morecomment=[f][\color{magenta}]{+++},
}

\lstdefinelanguage{plus}{
  basicstyle=\footnotesize\ttfamily\color{green!50!black},
  emph={see,below,TypeSwitch,unspecified},
  emphstyle=\itshape
}

\lstdefinelanguage{signature}{
  basicstyle=\ttfamily\color{green!50!black},
  emph={see,below,TypeSwitch,unspecified},
  emphstyle=\itshape
}

\newcommand{\desc}[1]{\textit{#1}}
\newcommand{\requires}{\desc{Requires}}
\newcommand{\effects}{\desc{Effects}}
\newcommand{\precondition}{\desc{Precondition}}
\newcommand{\postcondition}{\desc{Postcondition}}
\newcommand{\throws}{\desc{Throws}}
\newcommand{\returns}{\desc{Returns}}
\newcommand{\remarks}{\desc{Remarks}}
\newcommand{\exceptionsafety}{\desc{Exception Safety}}

\newcommand{\fullref}[1]{\ref{#1} \nameref{#1}}

\date{}
\title{constexpr std::shared_ptr}

\newcommand{\emailaddress}{graham.keir@gmail.com}
\newcommand{\email}{\href{mailto:\emailaddress}{\emailaddress}}

\begin{document}

\maketitle\vspace{-2cm}

\begin{flushright}
  \begin{tabular}{ll}
  Document \#:&P0080\\
  Date:       &\date{2015-07-28}\\
  Project:    &Programming Language C++\\
              &LEWG Library Evolution\\
  Reply-to:   &\author{Paul Keir}\\
              &\textless\email\textgreater
  \end{tabular}
\end{flushright}

{\hypersetup{linkcolor=black}
  \tableofcontents
}

\section{Revision History}

  - R4 2024-10-21
    - Added \texttt{constexpr} qualifier to the wording for \texttt{std::bad_weak_ptr} with \cite{P3068R4]
    - Updated ClangOz reference in motivation
  - R3 2024-09-03
    - Removed \texttt{constexpr} specification from \texttt{reinterpret_pointer_cast} (see below [here](#maybe-not-now-but-soon))
    - Added references to \cite{P3309R1} and \cite{P3068R4]
    - Added details of a second implementation based on libc++
  - R2 2024-05-24
    - Added wording
    - Removed \texttt{constexpr} specification from some functions (see below [here](#maybe-not-now-but-soon))
    - Removed SG7 from Audience (post 2024 Spring meeting in Tokyo)
  - R1 2024-03-05
    - Added a motivating example
    - Included libc++ & MSVC STL in atomic operation considerations
  - R0 2023-11-06
    - Original Proposal

\section{Introduction}

Since the adoption of \cite{P0784R7} in C++20, constant expressions can include
dynamic memory allocation; yet support for smart pointers extends only to
`std::unique_ptr} (since \cite{P2273R3} in C++23). As at runtime, smart
pointers can encourage hygienic memory management during constant evaluation;
and with no remaining technical obstacles, parity between runtime and
compile-time support for smart pointers should reflect the increased maturity
of language support for constant expression evaluation.  We therefore propose
that \texttt{std::shared_ptr} and appropriate class template member functions
from [smartptr]{.sref} permit \texttt{constexpr} evaluation.

\section{Motivation and Scope}

It is convenient when the same C++ code can be deployed both at runtime and
compile time. Our recent project investigates performance scaling of \emph{parallel}
constant expression evaluation in an experimental Clang compiler \cite{ClangOz]. As
well as C++17 parallel algorithms, a prototype \texttt{constexpr} implementation
of the Khronos SYCL API was utilised, where a SYCL \texttt{buffer` class abstracts
over device and/or host memory. In the simplified code excerpt below, the
\texttt{std::shared_ptr} data member ensures memory is properly deallocated upon
the \texttt{buffer}'s destruction, according to its owner status. This is a
common approach for runtime code, and a \texttt{constexpr}
`std::shared_ptr} class implementation helpfully bypasses thoughts of raw
pointers and preprocessor macros. The impact of adding \texttt{constexpr}
functionality to the SYCL implementation is therefore minimised.

\begin{lstlisting}[language=cpp]
template <class T, int dims = 1>
struct buffer
{
  constexpr buffer(const range<dims> &r)
    : range_{ r }, data_{ new T[r.size()], [this](auto* p){ delete [] p; } } { }

  constexpr buffer(T* hostData, const range<dims>& r)
    : range_{ r }, data_{ hostData, [](auto){} } { }

  const range<dims> range_{};
  std::shared_ptr<T[]> data_{};
};
\end{lstlisting}

Adopted C++26 proposal \cite{P2738R1} facilitates a straightforward implementation
of comprehensive \texttt{constexpr} support for \texttt{std::shared_ptr},
allowing the \texttt{get_deleter` member function to operate, given the type erasure
required within the \texttt{std::shared_ptr} unary class template. We
furthermore propose that the relational operators of \texttt{std::unique_ptr},
which can legally operate on pointers originating from a single allocation
during constant evaluation, should also adopt the \texttt{constexpr} specifier.

As with C++23 \texttt{constexpr} support for \texttt{std::unique_ptr`, bumping the
value \texttt{__cpp_lib_constexpr_memory` is our requested feature macro change; yet
in the discussion and implementation presented here, we adopt the macro
`__cpp_lib_constexpr_shared_ptr}.

We below elaborate on points which go beyond the simple addition of the
`constexpr} specifier to the relevant member functions.

\subsection{Revision History}

The existing \texttt{std::shared_ptr} class can operate within a multithreaded
runtime environment. A number of its member functions may therefore be defined
using atomic functions; so ensuring that shared state is updated correctly.
Atomic functions are not qualified as \texttt{constexpr}; but as constant
expressions must be evaluated by a single thread, a \texttt{constexpr}
`std::shared_ptr} implementation can safely skip calls to atomic
functions through the predication of \texttt{std::is_constant_evaluated} (or \texttt{if
consteval`). For example, here is a modified function from GCC's libstdc++,
called from \texttt{std::shared_ptr::use_count()} and elsewhere:

\begin{lstlisting}[language=cpp]
constexpr long
_M_get_use_count() const noexcept
{
#ifdef __cpp_lib_constexpr_shared_ptr
  return std::is_constant_evaluated()
           ? _M_use_count
           : __atomic_load_n(&_M_use_count, __ATOMIC_RELAXED);
#else
  return __atomic_load_n(&_M_use_count, __ATOMIC_RELAXED);
#endif
}
\end{lstlisting}

The use of atomic intrinsics within Clang's libc++ and MSVC's STL can be
elided similarly. In \texttt{__memory/shared_ptr.h`, libc++ makes calls to the atomic
intrinsic \texttt{__atomic_load_n}, only via the inline C++ functions
\texttt{__libcpp_relaxed_load} and \texttt{__libcpp_acquire_load}; while
\texttt{__atomic_add_fetch} is accessed only via
\texttt{__libcpp_atomic_refcount_increment} and
\texttt{__libcpp_atomic_refcount_decrement}. Each of these four functions is
comprised only of return statement pairs, predicated upon \emph{object-like} macros
including \texttt{_LIBCPP_HAS_NO_THREADS}; and so could easily be modified to
involve \texttt{std::is_constant_evaluated} as above.

In \texttt{stl/inc/memory`, the \texttt{std::shared_ptr} of MSVC's STL inherits a
\texttt{_Ref_count_base` member through \texttt{_Ptr_base`. \texttt{_Ref_count_base` has two
\texttt{_Atomic_counter_t` members (aliases of \texttt{unsigned long}), updated
atomically using the \texttt{_InterlockedCompareExchange};
\texttt{_InterlockedIncrement} (via the macro \texttt{_MT_INCR`); or
\texttt{_InterlockedDecrement} (via the macro \texttt{_MT_DECR`) atomic intrinsics. All
the (five) functions invoking these intrinsics can again make use of
\texttt{std::is_constant_evaluated` to avoid the atomic operations.

Adding \texttt{constexpr} support to an implementation of
`std::shared_ptr} utilising \texttt{std::atomic}
would need to take an alternative approach; likely involving the modification
of its \texttt{std::atomic} definition.
Recently, \cite{P3309R1} has proposed adding such \texttt{constexpr` functionality
to \texttt{std::atomic` (and \texttt{std::atomic_ref`) for C++26.

\subsection{Two Memory Allocations}

Unlike \texttt{std::unique_ptr`, a \texttt{std::shared_ptr} must store not only the
managed object, but also the type-erased deleter and allocator, as well as the
number of \texttt{std::shared_ptr}s and \texttt{std::weak_ptr}s which own or
refer to the managed object. This information is managed as part of a
dynamically allocated object referred to as the \emph{control block}.

Existing runtime implementations of \texttt{std::make_shared},
`std::allocate_shared},
`std::make_shared_for_overwrite}, and
`std::allocate_shared_for_overwrite}, allocate memory for both the
control block, \emph{and} the managed object, from a single dynamic memory
allocation; via \texttt{reinterpret_cast}.  This practise aligns with a remark
at [util.smartptr.shared.create]{.sref}; quoted below:

  - [7.1]{.pnum} Implementations should perform no more than one memory allocation.
  - [*Note 1*: This provides efficiency equivalent to an intrusive smart pointer.  — *end note*]

As \texttt{reinterpret_cast} is not permitted within a constant expression, an
alternative approach is required for \texttt{std::make_shared`,
`std::allocate_shared`, \texttt{std::make_shared_for_overwrite`, and
`std::allocate_shared_for_overwrite`.  A straightforward solution is to create
the object first, and pass its address to the appropriate
`std::shared_ptr} constructor. Considering the control block, this
approach amounts to two dynamic memory allocations; albeit at compile-time.
Assuming that the runtime implementation need not change, the remark quoted
above can be left unchanged; as this is only a recommendation, not a
requirement.

\subsection{Relational Operators}

Comparing dynamically allocated pointers within a constant expression is legal,
provided the result of the comparison is not unspecified.  Such comparisons are
defined in terms of a partial order, applicable to pointers which either point
"to different elements of the same array, or to subobjects thereof"; or to
"different non-static data members of the same object, or to subobjects of such
members, recursively..."; from paragraph 4 of [expr.rel]{.sref}. A simple
example program is shown below:

\begin{lstlisting}[language=cpp]
constexpr bool ptr_compare()
{
  int* p = new int[2]{};
  bool b = &p[0] < &p[1];
  delete [] p;
  return b;
}

static_assert(ptr_compare());
\end{lstlisting}

It is therefore unsurprising that we include the \texttt{std::shared_ptr}
relational operators within the scope of our proposal to apply
`constexpr} to all functions within [smartptr]{.sref}; the
`std::shared_ptr} aliasing constructor makes this especially simple to
configure:

\begin{lstlisting}[language=cpp]
constexpr bool sptr_compare()
{
  double *arr = new double[2];
  std::shared_ptr p{&arr[0]}, q{p, p.get() + 1};
  return p < q;
}

static_assert(sptr_compare());
\end{lstlisting}

Furthermore, in the interests of \texttt{constexpr} consistency, we propose that
the relational operators of \texttt{std::unique_ptr} *also* now include support
for constant evaluation. As discussed above, the results of such comparisons
are very often well defined.

It may be argued that a \texttt{std::unique_ptr} which is the sole owner of an
array, or an object with data members, presents less need for relational
operators. Yet we must consider that a custom deleter can easily change the
operational semantics; as demonstrated in the example below. A
`std::unique_ptr} should also be legally comparable with itself.

\begin{lstlisting}[language=cpp]
constexpr bool uptr_compare()
{
  short* p = new short[2]{};
  auto del = [](short*){};
  std::unique_ptr<short[]>               a{p+0};
  std::unique_ptr<short[],decltype(del)> b{p+1, del};
  return a < b;
}

static_assert(uptr_compare());
\end{lstlisting}

\subsection{Maybe Not Now, But Soon}

The functions from [smartptr]{.sref} listed below cannot possibly be evaluated
within a constant expression. We *do not* propose that their specifications
should change. While C++23's \cite{P2448R2} allows such functions to be annotated
as \texttt{constexpr}, we suggest that in this instance the C++ community will
be served better by a future update; when their constant evaluation becomes
possible.

  * [util.smartptr.hash]{.sref}: The \texttt{operator()` member of the class template specialisations for \texttt{std::hash<std::unique_ptr<T,D>>` and \texttt{std::hash<std::shared_ptr<T>>` cannot be defined according to the *Cpp17Hash* requirements ([hash.requirements]{.sref}). (A pointer cannot, during constant evaluation, be converted to an \texttt{std::size_t` using \texttt{reinterpret_cast}; or otherwise.)
  * [util.smartptr.owner.hash]{.sref}: The two \texttt{operator()` member functions of the recently adopted \texttt{owner_hash` class, also cannot be defined according to the *Cpp17Hash* requirements.
  * [util.smartptr.shared.obs]{.sref}: The recently adopted \texttt{owner_hash()` member function of \texttt{std::shared_ptr`, also cannot be defined according to the *Cpp17Hash* requirements.
  * [util.smartptr.weak.obs]{.sref}: The recently adopted \texttt{owner_hash()` member function of \texttt{std::weak_ptr`, also cannot be defined according to the *Cpp17Hash* requirements.
  * [util.smartptr.shared.cast]{.sref}: Neither of the two \texttt{reinterpret_pointer_cast} overloads can be included as their implementations will typically call \texttt{reinterpret_cast}, which is prohibited here.

We also *do not* propose any specification change for the overloads of
`operator<<} for \texttt{std::shared_ptr} and \texttt{std::unique_ptr},
from [util.smartptr.shared.io]{.sref} and [unique.ptr.io]{.sref}. Unlike the
functions above, a \texttt{constexpr} implementation for the
overloads could today use a vendor-specific extension; do
nothing; or simply report an error. But such possibilities should be
discussed in a separate proposal focused on I/O.

\section{Impact on the Standard}

This proposal is a pure library extension, and does not require any new language features.

\section{Implementation}

An implementation based on the GNU C++ Library (libstdc++) can be found
[here](https://github.com/SCT4SP/constexpr_shared_ptr). A comprehensive test
suite is included there within \texttt{tests/shared_ptr_constexpr_tests.cpp`;
alongside a standalone bash script to run it. All tests pass with recent GCC
and Clang (i.e. versions supporting \cite{P2738R1]; \texttt{__cpp_constexpr >= 202306L`).

A second implementation, by Hana Dusíková, based on the "libc++" C++ Library is
also available: on Github
[here](https://github.com/hanickadot/llvm-project/tree/P3309-constexpr-atomic-and-atomic-ref)
(via commit 23217d0); and with a corresponding Compiler Explorer instance
[here](https://compiler-explorer.com/z/8cj7nc1no).

\section{Proposed Wording}

The following wording changes apply to \cite{N4981} and can also be viewed on
Github via a fork of the *C++ Standard Draft Sources* repository
[here](https://github.com/cplusplus/draft/compare/20fa26d6...pkeir:draft:main).

\section{Acknowledgements}

Thanks to all of the following:

  - (In alphabetical order by last name.) Peter Dimov, Hana Dusíková, Thiago Macieira, Arthur O'Dwyer, Jonathan Wakely and everyone else who contributed to the BSI Panel and online forum discussions.

\pagebreak

---
references:
  - id: P0784R7
    citation-label: P0784R7
    title: "More constexpr containers"
    author:
      family: Dimov
      given: Peter
      family: Dionne
      given: Louis
      family: Ranns
      given: Nina
      family: Smith
      given: Richard
      family: Vandevoorde
      given: Daveed
    issued:
      year: 2019
    URL: https://wg21.link/p0784

  - id: P2738R1
    citation-label: P2738R1
    title: "`constexpr` cast from \texttt{void*`: towards \texttt{constexpr` type-erasure"
    author:
      family: Jabot
      given: Corentin
      family: Ledger
      given: David
    issued:
      year: 2023
    URL: https://wg21.link/p2738

  - id: P2448R2
    citation-label: P2448R2
    title: "Relaxing some \texttt{constexpr} restrictions"
    author:
      family: Revzin
      given: Barry
    issued:
      year: 2022
    URL: https://wg21.link/p2448

  - id: P2273R3
    citation-label: P2273R3
    title: "Making \texttt{std::unique_ptr` constexpr"
    author:
      family: Fertig
      given: Andreas
    issued:
      year: 2021
    URL: https://wg21.link/p2273

  - id: P3309R1
    citation-label: P3309R1
    title: "constexpr atomic<T> and atomic_ref<T>"
    author:
      family: Dusíková
      given: Hana
    issued:
      year: 2024
    URL: https://wg21.link/p3309

  - id: P3068R4
    citation-label: P3068R4
    title: "Allowing exception throwing in constant-evaluation"
    author:
      family: Dusíková
      given: Hana
    issued:
      year: 2024
    URL: https://wg21.link/p3068

  - id: ClangOz
    citation-label: ClangOz
    title: "ClangOz: Parallel constant evaluation of C++ map and reduce operations"
    author:
      family: Keir
      given: Paul
      family: Gozillon
      given: Andrew
    issued:
      year: 2024
    URL: https://doi.org/10.1016/j.cola.2024.101298
---
